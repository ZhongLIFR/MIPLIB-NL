{
  "abstract_problem": "EnLight is a finite combinatorial puzzle played on a rectangular board of {num_rows} rows and {num_cols} columns (with {num_cells} cells in total). Each cell of the board carries a light that can be either ON or OFF, and a move consists of selecting one cell and toggling its light together with the lights of its immediate neighbors above, below, left, and right (when those neighbors exist), creating a plus-shaped effect. The puzzle starts from a given initial position on this board, where a subset of cells is initially lit and the others are dark; this configuration is fully specified in the grid data and can be chosen to make the puzzle easy or particularly challenging. Because toggling the same cell twice would undo its effect, each cell is either chosen once as a move or not chosen at all. The goal is to find a sequence of moves (a subset of cells to toggle) that transforms the initial position into a terminal position where all lights are OFF, while minimizing the total number of moves played. The mixed-integer programming model for this instance represents each potential move as a binary decision variable and enforces, for every cell, that the parity of all moves affecting it is consistent with its initial ON/OFF state.",
  "parameters": {
    "num_rows": "10",
    "num_cols": "10",
    "num_cells": "100",
    "num_moves": "100"
  },
  "files": {
    "grid": {
      "path": "data/grid.csv",
      "description": "Board layout and initial light configuration for all cells in the EnLight puzzle. Each row corresponds to one cell of the {num_rows} × {num_cols} board.\n\nColumns:\n- `cell_id`: 1-based identifier of the cell, running row by row from top-left to bottom-right; in this instance `cell_id = (row - 1) * {num_cols} + col`.\n- `row`: row index of the cell, from 1 to {num_rows}, with 1 being the top row of the board.\n- `col`: column index of the cell, from 1 to {num_cols}, with 1 being the leftmost column.\n- `initial_state`: initial ON/OFF state of the light on this cell (1 = ON, 0 = OFF). The optimization model enforces that, after applying all selected moves, every cell’s final state is OFF.\n\nIn `enlight_hard`, the initial configuration is a deliberately challenging pattern on the 10×10 board with many lit cells (for example, several lights along borders and in the interior); see the `initial_state` column for the exact layout.\n\nData format:\n| cell_id | row | col | initial_state |\n|---------|-----|-----|---------------|\n| 1       | 1   | 1   | 1             |\n| 2       | 1   | 2   | 0             |\n| ...     | ... | ... | ...           |\n| 100     | 10  | 10  | 0             |"
    },
    "moves": {
      "path": "data/moves.csv",
      "description": "Set of available moves in the EnLight puzzle, one potential move per board cell. Each move corresponds to choosing a cell once and applying the plus-shaped light toggle centered at that cell.\n\nColumns:\n- `move_id`: 1-based identifier of the move; in this instance, there is exactly one move per cell, so `move_id = (move_row - 1) * {num_cols} + move_col` and `num_moves = {num_moves}`.\n- `move_row`: row index of the cell where the move is played (the move’s center), from 1 to {num_rows}.\n- `move_col`: column index of the cell where the move is played, from 1 to {num_cols}.\n\nIn the optimization model, each move is associated with a binary decision variable indicating whether that move is used (1) or not used (0).\n\nData format:\n| move_id | move_row | move_col |\n|---------|----------|----------|\n| 1       | 1        | 1        |\n| 2       | 1        | 2        |\n| 3       | 1        | 3        |\n| 4       | 1        | 4        |\n| ...     | ...      | ...      |\n| 100     | 10       | 10       |"
    },
    "move_effects": {
      "path": "data/move_effects.csv",
      "description": "Neighborhood effect of each move on the EnLight board. Each row states that a given move (played at some cell) affects the light state of a given target cell. In `enlight_hard`, every move affects its own cell and its orthogonal neighbors (up/down/left/right) when those neighbors exist, creating a plus-shaped pattern centered at the move’s cell.\n\nColumns:\n- `move_id`: identifier of the move, matching `moves.csv`.\n- `move_row`: row index of the move’s center cell, repeated for readability (can be derived from `move_id`).\n- `move_col`: column index of the move’s center cell, repeated for readability.\n- `cell_id`: identifier of the affected cell, matching `grid.csv`.\n- `cell_row`: row index of the affected cell, repeated for readability.\n- `cell_col`: column index of the affected cell, repeated for readability.\n\nIn the mixed-integer model, for each cell you sum the binary move variables of all moves that affect it (as listed here), add its `initial_state`, and impose an even-parity condition so that the final light state is OFF.\n\nData format:\n| move_id | move_row | move_col | cell_id | cell_row | cell_col |\n|---------|----------|----------|---------|----------|----------|\n| 1       | 1        | 1        | 1       | 1        | 1        |\n| 2       | 1        | 2        | 1       | 1        | 1        |\n| 11      | 2        | 1        | 1       | 1        | 1        |\n| ...     | ...      | ...      | ...     | ...      | ...      |"
    }
  },
  "optimal_value": "37"
}
