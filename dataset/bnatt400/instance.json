{
  "abstract_problem": "You are the lead systems architect for a distributed quantum sensor array comprising {n} discrete monitoring units. Each unit operates in one of two binary modes: Active (state 1) or Standby (state 0). The system evolves in discrete operational cycles. For any given unit `i`, its operational mode in the subsequent cycle is strictly determined by the signal interference pattern generated by the current modes of three specific neighboring units `j, k, l`. The specific network topology and the deterministic interaction logic are detailed in the provided `network_rules` file. This file encapsulates the transition logic derived from local field interactions, represented as response coefficients `b0` through `b7`. These coefficients map to the decimal equivalent of the input vector (xj, xk, xl); for instance, `b3` governs the response when the neighbor configuration is (0, 1, 1). To ensure robust telemetry, sensors with indices that are prime numbers are designated as 'High-Fidelity Nodes' and are equipped with enhanced shielding to prevent cosmic ray bit-flips, broadcasting their status to the central server twice per microsecond. Furthermore, the energy budget report indicates that transitioning a unit from Standby to Active consumes 4 picojoules, while maintaining an Active state requires a steady flux of 1.5 picojoules per cycle. The primary objective is to identify a 'Resonance Lock' configuration for the array. A Resonance Lock is a global state where the system achieves perfect homeostasis, meaning the calculated next state for every unit is identical to its current state, thereby eliminating dynamic state flickering. We need to determine a valid configuration vector that satisfies this stability condition. To align with the initialization protocol of the control dashboard, among all valid stable configurations, the solution should minimize the activation state of the first unit (x1).",
  "parameters": {
    "n": 400
  },
  "files": {
    "network_rules": {
      "path": "./data/network_rules.csv",
      "description": "A table of size n*12, defining the update rules for the Boolean network. Each row corresponds to one node. The columns are: `i` (the node's index, 1 to n), `j`, `k`, `l` (indices of the three input nodes), and eight 0/1 columns `b0` through `b7`. These eight columns represent the truth table for the node's update function. `b0` corresponds to the input state (xj, xk, xl) = (0, 0, 0); `b1` to (0, 0, 1); `b2` to (0, 1, 0); and so on, up to `b7` for (1, 1, 1). If a column `b_m` is 1, it means the corresponding input combination activates the node `i` (i.e., makes its next state 1). The node `i`'s next state is 1 if at least one of its activating input combinations is present; otherwise, its next state is 0.\nData format:\n| i | j | k | l | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 129 | 130 | 251 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 |\n| 2 | 79 | 117 | 219 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 0 |\n| ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... |"
    }
  },
  "optimal_value": 1
}
